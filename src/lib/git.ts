import { simpleGit, SimpleGit } from "simple-git";
import { execSync } from "child_process";
import { existsSync } from "fs";
import { resolve } from "path";

export interface GitWorkflowOptions {
  repoPath: string;
  baseBranch: string;
  featureBranch: string;
}

/**
 * Prepare repository for extension generation
 */
export async function prepareRepository(
  options: GitWorkflowOptions
): Promise<SimpleGit> {
  const repoPath = resolve(options.repoPath);

  // Check if directory exists
  if (!existsSync(repoPath)) {
    throw new Error(
      `Repository not found at ${repoPath}. Please clone editor-extensions first.`
    );
  }

  const git = simpleGit(repoPath);

  // Verify it's a git repository
  const isRepo = await git.checkIsRepo();
  if (!isRepo) {
    throw new Error(`${repoPath} is not a git repository`);
  }

  // Fetch latest from remote
  try {
    await git.fetch("origin");
  } catch (error) {
    // Fetch may fail if offline, continue anyway
    console.warn("Warning: Could not fetch from remote");
  }

  // Check for uncommitted changes (ignore untracked files)
  const status = await git.status();
  const hasUncommittedChanges =
    status.staged.length > 0 ||
    status.modified.length > 0 ||
    status.deleted.length > 0 ||
    status.conflicted.length > 0;

  if (hasUncommittedChanges) {
    throw new Error(
      "Repository has uncommitted changes. Please commit or stash them first."
    );
  }

  // Check if branch already exists
  const branches = await git.branch();
  if (branches.all.includes(options.featureBranch)) {
    throw new Error(
      `Branch '${options.featureBranch}' already exists. Use a different branch name or delete the existing branch.`
    );
  }

  // Create feature branch from base branch
  try {
    await git.checkout([
      "-b",
      options.featureBranch,
      `origin/${options.baseBranch}`,
    ]);
  } catch {
    // If origin/baseBranch doesn't exist, try local branch
    await git.checkout(["-b", options.featureBranch, options.baseBranch]);
  }

  return git;
}

/**
 * Commit generated changes
 */
export async function commitChanges(
  git: SimpleGit,
  language: string,
  displayName: string
): Promise<string> {
  await git.add(".");

  const commitMessage = `feat: add ${displayName} extension

- Add vscode/${language}/ extension scaffold
- Update root package.json with workspace
- Update CI workflows for ${language} extension
- Update asset collection scripts

Generated by extension-generator`;

  await git.commit(commitMessage);

  // Get commit hash
  const log = await git.log({ maxCount: 1 });
  return log.latest?.hash || "";
}

/**
 * Push branch and create PR
 */
export async function pushAndCreatePR(
  git: SimpleGit,
  options: {
    branch: string;
    language: string;
    displayName: string;
  }
): Promise<string> {
  const cwd = await git.revparse(["--show-toplevel"]);

  // Create PR using gh CLI
  const prBody = `## Summary
- Add ${options.displayName} language extension
- Generated by extension-generator tool

## Files Added
- \`vscode/${options.language}/\` - Extension source code
- Updated CI workflows
- Updated build scripts

## Testing
- [ ] Build passes (\`npm run build\`)
- [ ] Extension activates correctly
- [ ] Provider starts successfully
- [ ] Analysis runs without errors

---
Generated with [extension-generator](https://github.com/savitharaghunathan/extension-generator)`;

  try {
    const result = execSync(
      `gh pr create --title "feat: Add ${options.displayName} Extension" --body "${prBody.replace(/"/g, '\\"')}"`,
      { encoding: "utf-8", cwd: cwd.trim() }
    );
    return result.trim();
  } catch (error) {
    throw new Error(
      `Failed to create PR. Make sure gh CLI is installed and authenticated.`
    );
  }
}
