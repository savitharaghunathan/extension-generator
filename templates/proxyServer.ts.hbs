import * as net from "net";
import * as fs from "fs";
import winston from "winston";
import * as vscode from "vscode";
import {
  createMessageConnection,
  StreamMessageReader,
  StreamMessageWriter,
  MessageConnection,
} from "vscode-jsonrpc/node";

export class {{pascalLanguage}}VscodeProxyServer implements vscode.Disposable {
  private server: net.Server | null = null;
  private connections: MessageConnection[] = [];

  constructor(
    private readonly logger: winston.Logger,
    private readonly socketPath: string
  ) {}

  async start(): Promise<void> {
    // Remove existing socket if present
    if (fs.existsSync(this.socketPath)) {
      fs.unlinkSync(this.socketPath);
    }

    return new Promise((resolve, reject) => {
      this.server = net.createServer((socket) => {
        this.handleConnection(socket);
      });

      this.server.on("error", (err) => {
        this.logger.error(`Proxy server error: ${err.message}`);
        reject(err);
      });

      this.server.listen(this.socketPath, () => {
        this.logger.info(`LSP proxy server listening on ${this.socketPath}`);
        resolve();
      });
    });
  }

  private handleConnection(socket: net.Socket): void {
    this.logger.debug("New client connected to LSP proxy");

    const reader = new StreamMessageReader(socket);
    const writer = new StreamMessageWriter(socket);
    const connection = createMessageConnection(reader, writer);

    connection.onRequest((method, params) => {
      this.logger.debug(`LSP request: ${method}`);
      // Forward to language server
      return this.forwardRequest(method, params);
    });

    connection.onNotification((method, params) => {
      this.logger.debug(`LSP notification: ${method}`);
      // Forward to language server
      this.forwardNotification(method, params);
    });

    connection.onClose(() => {
      this.logger.debug("Client disconnected from LSP proxy");
      const index = this.connections.indexOf(connection);
      if (index > -1) {
        this.connections.splice(index, 1);
      }
    });

    connection.listen();
    this.connections.push(connection);
  }

  private async forwardRequest(method: string, params: unknown): Promise<unknown> {
    // TODO: Implement request forwarding to actual language server
    this.logger.debug(`Forwarding request: ${method}`);
    return null;
  }

  private forwardNotification(method: string, params: unknown): void {
    // TODO: Implement notification forwarding to actual language server
    this.logger.debug(`Forwarding notification: ${method}`);
  }

  dispose(): void {
    this.connections.forEach((conn) => conn.dispose());
    this.connections = [];

    if (this.server) {
      this.server.close();
      this.server = null;
    }

    if (fs.existsSync(this.socketPath)) {
      fs.unlinkSync(this.socketPath);
    }
  }
}
